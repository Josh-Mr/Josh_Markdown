{
	"ID": "20220112171608-fgkfiez",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20220112171608-fgkfiez",
		"title": "Java之学习DEMO2",
		"updated": "20220112171619"
	},
	"Children": [
		{
			"ID": "20220112171608-95td5vv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220112171608-95td5vv",
				"updated": "20220112171613"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Equalsf方法\n 随机生成 50 个数字（整数），每个数字的范围是[10, 50]，统计每个数字出现的次数\n以及 出现次数最多的数字与它的个数，最后将每个数字及其出现次数打印出来，如果某个数\n字出现次数为 0，则不要打印它。打印时按照数字的升序排列。\nequals\npublic boolean equals(Object obj)\n指示其他某个对象是否与此对象“相等”。\nequals 方法在非空对象引用上实现相等关系：\n自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。\n对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。\n传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。\n一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。\n对于任何非空引用值 x，x.equals(null) 都应返回 false。\n拆箱包箱\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class SrotDemo {\n     public static void main(String[] args) {\n          // 先获得系统输入的args\n          // 右键runconfig。。。\n          Map\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e();\n          // 遍历agrs\n          for (String a : args) {\n               // 通过ket找出value的值\n               Integer aa = map.get(a);\n               // 自动拆箱和自动包箱\n               map.put(a, (aa == null) ? 1 : aa + 1);\n          }\n          System.out.println(map);\n     }\n}\n☆通过Java的反射机制实现方法对Customer对象的拷贝操作\nimport java.io.File;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\npublic class ReflectionDemo {\n    //该方法实现对conmon对象拷贝操作\n    public Object copy(Object object) throws Exception{\n         //通过对象拿到class类\n         Class\u003c?\u003e classType = object.getClass();\n         //cope该class的对象\n         Object classCope= classType.getConstructor(new Class[]{}).newInstance(new Object[]{});\n     \n         //获取该对象的所有成员变量\n         Field[] fields = classType.getDeclaredFields();\n         for(Field file:fields){\n             //获取变量名\n             String fName = file.getName();\n             String oneName = fName.substring(0, 1).toUpperCase();// 将属性的首字母转换为大写(0,1)表示第一个字符\n             String getNames = \"get\"+oneName+fName.substring(1);//这样写substring(1,fName.length()也可以的\n             String setNames = \"set\"+oneName+fName.substring(1);\n             //通过class获取getMethod(方法名，方法参数)方法\n             Method getmethod = classType.getMethod(getNames, new Class[]{});\n             Method setmethod = classType.getMethod(setNames, new Class[]{file.getType()});//file.getType()获取file的类型\n         \n             Object value = getmethod.invoke(object, new Object[]{});//把外面的Object对象传进来，通过启动getmethod方法\n         \n             setmethod.invoke(classCope, new Object[]{value});//拷贝的对象调用setmethod()把Value传进去\n         }\n         return classCope;\n    }\n  \n    public static void main(String[] args) throws Exception{\n     \n         Conmon conmon = new Conmon(\"shabi\",12);\n         conmon.setId(100L);//或者conmon.setId(new long(100));\n     \n         //把conmon对象传进去\n         ReflectionDemo reflectionDemo = new ReflectionDemo();\n         reflectionDemo.copy(conmon);\n     \n         System.out.println(\"ID:\"+conmon.getId()+ \" Name:\"+conmon.getName()+\" Age:\"+conmon.getAge());\n    }\n}\nclass Conmon {\n  \n    private Long id;//Long型id\n    private String name;\n    private int age;\n  \n    public Conmon() {\n    }\n    public Conmon(String string,int in){\n         this.name=string;\n         this.age=in;\n    }\n    public Long getId() {\n         return id;\n    }\n    public void setId(Long id) {\n         this.id = id;\n    }\n    public String getName() {\n         return name;\n    }\n    public void setName(String name) {\n         this.name = name;\n    }\n    public int getAge() {\n         return age;\n    }\n    public void setAge(int age) {\n         this.age = age;\n    }\n  \n}\nThread 线程\n2.new\npublic class NewThread {\n    public static void main(String[] args) {\n         new Thread(new StudyThreadTest1()).start();\n         new Thread(new StudyThreadTest2()).start();\n         // 内部类创建\n         new Thread(new Runnable() {\n             @Override\n             public void run() {\n                  for (int i = 0; i \u003c 100; i++) {\n                      if (i == 10) {\n                          break;\n                      }\n                      try {\n                          Thread.sleep((long) (Math.random() * 1000));\n                          System.out.println(\"world:\" + i);\n                      } catch (InterruptedException e) {\n                          // TODO Auto-generated catch block\n                          e.printStackTrace();\n                      }\n                  }\n             }\n         }).start();\n         // 加个false方法\n         new Thread(new Runnable() {\n             private boolean CHANG = true;\n             public void run() {\n                  int i = 0;\n                  while (CHANG) {\n                      try {\n                          Thread.sleep(1000);\n                          System.out.println(\"guanhuaqin\" + i++);\n                      } catch (InterruptedException e) {\n                          // TODO Auto-generated catch block\n                          e.printStackTrace();\n                      }\n                      if (i == 10) {\n                          changTest();\n                      }\n                  }\n             }\n             private boolean changTest() {\n                  return this.CHANG = false;\n             }\n         }).start();\n    }\n}\n// 继承Thread\nclass StudyThreadTest1 extends Thread {\n    public void run() {\n         for (int i = 0; i \u003c 100; i++) {\n             if (i == 10) {\n                  break;\n             }\n             try {\n                  Thread.sleep((long) (Math.random() * 1000));\n                  System.out.println(\"Hello:\" + i);\n             } catch (InterruptedException e) {\n                  // TODO Auto-generated catch block\n                  e.printStackTrace();\n             }\n         }\n    }\n}\n// 实现Runnable接口\nclass StudyThreadTest2 implements Runnable {\n    @Override\n    public void run() {\n         for (int i = 0; i \u003c 100; i++) {\n             if (i == 10) {\n                  break;\n             }\n             try {\n                  Thread.sleep((long) (Math.random() * 1000));\n                  System.out.println(\"welcome:\" + i);\n             } catch (InterruptedException e) {\n                  // TODO Auto-generated catch block\n                  e.printStackTrace();\n             }\n         }\n    }\n}\n2.线程的synchronized关键字\n    public void execute2()\n    {\n        synchronized(this)\n        {\n            for (int i = 0; i \u003c 20; i++)\n            {\n                try\n                {\n                   Thread.sleep((long) (Math.random() * 1000));\n                }\n                catch (InterruptedException e)\n                {\n                   e.printStackTrace();\n                }\n                System.out.println(\"world: \" + i);\n            }\n        }\n    \n    \n    }\n--------------------------------------------------------------------------------------------------------------------------------------------------------\npublic class SynchronizedDemo {\n    public static void main(String[] args) {\n         Bank bank = new Bank();\n         //两个线程公用一个对象\n         Thread thread = new ThreadDemo(bank);\n         Thread thread1 = new ThreadDemo(bank);\n         thread.start();\n         thread1.start();\n    }\n}\nclass Bank {\n    private int mo = 1000;\n    /*\n     * 2、synchronized关键字\n     * Java 中的每个对象都有一个锁（lock）或者叫做监视器（monitor），\n     * 当访问某个对 象的 synchronized 方法时，表示将该对象上锁，此时其他任何线程都无法再去访问 该 synchronized 方法了，\n     * 直到之前的那个线程执行方法完毕后（或者是抛出了异常） ，那么将该对象的锁释放掉，其他线程才有可能再去访问该 synchronized 方法。\n     */\n    public synchronized  int money(int numbers) {\n         if (numbers \u003c 0) {\n             return -1;\n         } else if (numbers \u003e mo) {\n             return -2;\n         } else {\n             /*1、当不加synchronized关键字时，可能两个线程同时执行\n              * 导致Money出现负数\n              *\n              */\n             try {\n                  Thread.sleep(1000);\n             } catch (InterruptedException e) {\n                  // TODO Auto-generated catch block\n                  e.printStackTrace();\n             }\n             //休眠后刚好执行\n             mo -= numbers;\n         }\n         System.out.println(\"Money:\" + mo);\n         return numbers;\n    }\n}\nclass ThreadDemo extends Thread {\n    private Bank bank;\n    public ThreadDemo(Bank bank) {\n         this.bank = bank;\n    }\n    public void run() {\n         System.out.println(bank.money(800));\n    }\n}\n3.synchronize和static\npublic class SynchronizeStatic {\n/*\n * 1、关键字Synchronize是对于对象来说的。\n * a)若同一个对象的两个相同线程，则是有序的\n * b)若两个对象的两个线程，则是无序的\n * 2、关键字Static对于class的唯一对象来说\n * a)如果某个 synchronized 方法是 static 的，那么当线程访问该方法时\n * ，它锁的并不是 synchronized 方法所在的对象，\n * 而是 synchronized 方法所在的对象所对应的 Class 对 象，\n * 因为 Java 中无论一个类有多少个对象，这些对象会对应唯一一个 Class 对象,\n *  因此当线程分别访问同一个类的两个对象的两个 static，synchronized 方法时，\n * 他们 的执行顺序也是顺序的，也就是说一个线程先去执行方法，\n * 执行完毕后另一个线程 才开始执行\n */\n    public static void main(String[] args) {\n         SynchronizeAndStatic s = new SynchronizeAndStatic();\n//       SynchronizeAndStatic s2 = new SynchronizeAndStatic();\n         Thread1 t1 = new Thread1(s);\n         Thread2 t2 = new Thread2(s);\n         t1.start();\n         t2.start();\n     \n     \n    }\n}\nclass SynchronizeAndStatic {\n    public synchronized static void test1() {\n         for (int i = 0; i \u003c 10; i++) {\n             try {\n                  Thread.sleep((long) (Math.random()) * 1000);\n             } catch (InterruptedException e) {\n                  // TODO Auto-generated catch block\n                  e.printStackTrace();\n             }\n             System.out.println(\"Hello:\" + i);\n         }\n    }\n    public  synchronized static void test2(){\n         for (int i = 0; i \u003c 10; i++) {\n             try {\n                  Thread.sleep((long) (Math.random()) * 1000);\n             } catch (InterruptedException e) {\n                  // TODO Auto-generated catch block\n                  e.printStackTrace();\n             }\n             System.out.println(\"Welcome:\" + i);\n         }\n    }\n}\nclass Thread1 extends Thread{\n  \n    private SynchronizeAndStatic synchronizeAndStatic;\n  \n    public Thread1(SynchronizeAndStatic synchronizeAndStatic) {\n    this.synchronizeAndStatic=synchronizeAndStatic;\n    }\n  \n    @Override\n    public void run() {\n         this.synchronizeAndStatic.test1();\n    }\n}\nclass Thread2 extends Thread{\n  \n    private SynchronizeAndStatic synchronizeAndStatic;\n  \n    public Thread2(SynchronizeAndStatic synchronizeAndStatic) {\n    this.synchronizeAndStatic=synchronizeAndStatic;\n    }\n  \n    @Override\n    public void run() {\n         this.synchronizeAndStatic.test2();\n    }\n}\n4.wait 和 notify\npublic class WaitAndNotify {\n    public static void main(String[] args) {\n         Type type = new Type();\n         Thread th1 = new WaitThread1(type);\n         Thread th2 = new WaitThread2(type);\n         th1.start();\n         th2.start();\n    }\n}\nclass Type {\n    private int numders;\n    public synchronized int typeTest1() {\n         if (numders != 0) {\n             try {\n                  wait();\n             } catch (InterruptedException e) {\n                  // TODO Auto-generated catch block\n                  e.printStackTrace();\n             }\n         }\n         numders += 1;\n         System.out.println(numders);\n         notify();\n         return numders;\n    }\n    public synchronized int typeTest2() {\n         if (numders != 1) {\n             try {\n                  wait();\n             } catch (InterruptedException e) {\n                  // TODO Auto-generated catch block\n                  e.printStackTrace();\n             }\n         }\n         numders -= 1;\n         System.out.println(numders);\n         notify();\n         return numders;\n    }\n}\nclass WaitThread1 extends Thread {\n    private Type type;\n    public WaitThread1(Type type) {\n         this.type = type;\n    }\n    public void run() {\n         while (Chang.Chang) {\n             for (int i = 0; i \u003c 100; i++) {\n                  type.typeTest1();\n                  if (i == 10) {\n                      Chang.changDemo();\n                  }\n             }\n         }\n    }\n}\nclass WaitThread2 extends Thread {\n    private Type type;\n    public WaitThread2(Type type) {\n         this.type = type;\n    }\n    public void run() {\n         while (Chang.Chang) {\n             for (int i = 0; i \u003c 100; i++) {\n                  type.typeTest2();\n                  if (i == 10) {\n                      Chang.changDemo();\n                  }\n             }\n         }\n    }\n}\nclass Chang {\n    public static Boolean Chang = true;\n    public static void changDemo() {\n         Chang = false;\n    }\n}\nTCP网络编程\nMainClient.java\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\npublic class MainClient {\n    public static void main(String[] args) throws Exception {\n         Socket socket = new Socket(\"127.0.0.1\", 8001);\n         new ClientInputThread(socket).start();\n         new ClientOutputThread(socket).start();\n    }\n}\n//ClientInputThread\nclass ClientInputThread extends Thread {\n    private Socket socket;\n    public ClientInputThread(Socket socket) {\n         this.socket = socket;\n    }\n    public void run() {\n         try {\n             InputStream clientIn = socket.getInputStream();\n             while (true) {\n                  byte[] buffer = new byte[1024];\n                  int len = clientIn.read(buffer);\n                  System.out.println(new String(buffer, 0, len));\n             }\n         } catch (IOException e) {\n             // TODO Auto-generated catch block\n             e.printStackTrace();\n         }\n    }\n}\n//ClientOutputThread\nclass ClientOutputThread extends Thread {\n    private Socket socket;\n    public ClientOutputThread(Socket socket) {\n         this.socket = socket;\n    }\n    public void run() {\n         try {\n             OutputStream clientOut = socket.getOutputStream();\n             while (true) {\n                  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n                  clientOut.write((bufferedReader.readLine()).getBytes());\n             }\n         } catch (IOException e) {\n             // TODO Auto-generated catch block\n             e.printStackTrace();\n         }\n    }\n}\nMainserver.java\npackage MainServer;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class MainServer {\n    public static void main(String[] args) throws Exception {\n         ServerSocket serverSocket = new ServerSocket(8001);\n         while (true) {\n             //当没有客户端连接是是属于阻塞状态\n             Socket socket = serverSocket.accept();\n             new ServerInputThread(socket).start();\n             new ServerOutputThread(socket).start();\n         }\n    }\n}\n//ServerInputThread\nclass ServerInputThread extends Thread {\n    private Socket socket;\n    public ServerInputThread(Socket socket) {\n         this.socket = socket;\n    }\n    @Override\n    public void run() {\n         try {\n             InputStream serverIn = socket.getInputStream();\n             while (true) {\n                  byte[] buffer = new byte[1024];\n                  int len = serverIn.read(buffer);\n                  System.out.println(new String(buffer, 0, len));\n             }\n         } catch (IOException e) {\n             // TODO Auto-generated catch block\n             e.printStackTrace();\n         }\n    }\n}\n//ServerOutputThread\nclass ServerOutputThread extends Thread {\n    private Socket socket;\n    public ServerOutputThread(Socket socket) {\n         this.socket = socket;\n    }\n    @Override\n    public void run() {\n         try {\n             OutputStream serverOut = socket.getOutputStream();\n             while (true) {\n                  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n                  String len = bufferedReader.readLine();\n                  serverOut.write(len.getBytes());\n             }\n         } catch (IOException e) {\n             // TODO Auto-generated catch block\n             e.printStackTrace();\n         }\n    }\n}\nUdp\nUdpTest1.java\npackage UDPDatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\npublic class UdpTest1 {\n    public static void main(String[] args) throws Exception {\n         //发送端\n         DatagramSocket socket = new DatagramSocket();\n         String string = \"Hello\";\n         //string.getBytes()转为字符, string.length()获取长度,InetAddress.getByName(\"localhost\")获取到本地的主机名, 4002端口号\n     \n         DatagramPacket packet = new DatagramPacket(string.getBytes(), string.length(),InetAddress.getByName(\"localhost\"), 4002);\n     \n         socket.send(packet);\n//------------------------------------------------------------------------------------\n     \n         //接收端\n         byte[] buffer = new byte[1024];\n     \n         //把接受到的信息存到buffer\n     \n         DatagramPacket packet2 = new DatagramPacket(buffer, 1024);\n         socket.receive(packet2);\n         //packet2.getLength()是获得数据报的长度\n         System.out.println(new String(buffer, 0, packet2.getLength()));\n         socket.close();\n    }\n}\nUdpTest2.java\npackage UDPDatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\npublic class UdpTest2 {\n    public static void main(String[] args) throws Exception {\n         //先开始监听端口号4002\n         DatagramSocket socket = new DatagramSocket(4002);\n     \n         byte[] buffer = new byte[1024];\n         DatagramPacket packet = new DatagramPacket(buffer, 1024);\n         socket.receive(packet);\n         System.out.println(new String(buffer, 0, packet.getLength()));\n     \n     \n//----------------------------------------------------------------\n     \n     \n         String str = \"welcome\";\n         //通过传来的packet,获得传来的主机信息packet.getAddress()获得主机名,packet.getPort()获得端口号\n         DatagramPacket pactek2 = new DatagramPacket(str.getBytes(), str.length(), packet.getAddress(),packet.getPort());\n         socket.send(pactek2);\n         socket.close();\n    }\n}    \n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}