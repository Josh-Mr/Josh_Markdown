{
	"ID": "20220124162829-e82zo4n",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20220124162829-e82zo4n",
		"title": "面试题",
		"updated": "20220124162835"
	},
	"Children": [
		{
			"ID": "20220124162835-ovpplvx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-ovpplvx",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java 面试常问问题及答案（非常详细）"
				}
			]
		},
		{
			"ID": "20220124162835-omdas3e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-omdas3e",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一：java 基础"
				}
			]
		},
		{
			"ID": "20220124162835-6s8nnt6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-6s8nnt6",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.简述 string 对象，StringBuffer、StringBuilder 区分"
				}
			]
		},
		{
			"ID": "20220124162835-v9l2hnv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-v9l2hnv",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "string 是 final 的，内部用一个 final 类型的 char 数组存储数据，它的拼接效率比较低，实际上是通过建立一个 StringBuffer,让后台调用 append(),最后再将 StringBuffer toSting()，每次操作 Sting 都会重新建立新的对象来保存新的值.这样原来的对象就没用了,就要被垃圾回收.这也是要影响性能的。"
				}
			]
		},
		{
			"ID": "20220124162835-asbe9el",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-asbe9el",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "StringBuffer 也是 final,线程安全的，中采用一个 char 数组来保存需要 append 的字符串，char 数组有一个初始大小，当 append 的字符串长度超过当前 char 数组容量时，则对 char 数组进行动态扩展，也即重新申请一段更大的内存空间，然后将当前 char 数组拷贝到新的位置，因为重新分配内存并拷贝的开销比较大，所以每次重新申请内存空间都是采用申请大于当前需要的内存空间的方式，这里是 2 倍。"
				}
			]
		},
		{
			"ID": "20220124162835-s6rkpzn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-s6rkpzn",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "StringBuilder，线程不安全。"
				}
			]
		},
		{
			"ID": "20220124162835-723jivy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-723jivy",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.多态的原理"
				}
			]
		},
		{
			"ID": "20220124162835-8ba2pxg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-8ba2pxg",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态就是：允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。"
				}
			]
		},
		{
			"ID": "20220124162835-dl07pmq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-dl07pmq",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原理是 java 的后期绑定。"
				}
			]
		},
		{
			"ID": "20220124162835-inukic6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-inukic6",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.简要描述面向对象编程的思想"
				}
			]
		},
		{
			"ID": "20220124162835-xtdofgv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-xtdofgv",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "抽象：通过特定的实例抽取出共同的特征以后形成的概念的过程，它强调主要特征和忽略次要特征。"
				}
			]
		},
		{
			"ID": "20220124162835-5gh8mnr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-5gh8mnr",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "封装：把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。"
				}
			]
		},
		{
			"ID": "20220124162835-3zb702h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-3zb702h",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承：从已知的一个类中派生出新的一个类，叫子类。子类实现了父类所有非私有化属性和方法，"
				}
			]
		},
		{
			"ID": "20220124162835-j8n8xps",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-j8n8xps",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "并能根据自己的实际需求扩展出新的行为。"
				}
			]
		},
		{
			"ID": "20220124162835-z121sg4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-z121sg4",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态：多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的行为方法。"
				}
			]
		},
		{
			"ID": "20220124162835-nxt6p3x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-nxt6p3x",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.反射的原理"
				}
			]
		},
		{
			"ID": "20220124162835-599oxb5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-599oxb5",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java 虚拟机运行时内存有个叫方法区，主要作用是存储被装载的类的类型信息。每装载一个类的时候，java 就会创建一个该类的 Class 对象实例。我们就可以通过这个实例，来访问这个类的信息。"
				}
			]
		},
		{
			"ID": "20220124162835-j69kyxp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-j69kyxp",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5.代理的作用和实现"
				}
			]
		},
		{
			"ID": "20220124162835-vplwexp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-vplwexp",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。"
				}
			]
		},
		{
			"ID": "20220124162835-x9aw22o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-x9aw22o",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java 的静态代理和动态代理（略）"
				}
			]
		},
		{
			"ID": "20220124162835-dyo298p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-dyo298p",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6.hashcode 和 equals 的用法"
				}
			]
		},
		{
			"ID": "20220124162835-ms10s8y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-ms10s8y",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java 对于 eqauls 方法和 hashCode 方法是这样规定的："
				}
			]
		},
		{
			"ID": "20220124162835-wbcg5zy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-wbcg5zy",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果两个对象相同，那么它们的 hashCode 值一定要相同；"
				}
			]
		},
		{
			"ID": "20220124162835-dd3ue4p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-dd3ue4p",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果两个对象的 hashCode 相同，它们并不一定相同（上面说的对象相同指的是用 eqauls 方法比较。）"
				}
			]
		},
		{
			"ID": "20220124162835-o9wl506",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-o9wl506",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一般在覆盖 equals()方法的同时也要覆盖 hashCode()方法，否则，就会违反 Object.hashCode 的通用约定，从而导致该类无法与所有基于散列值(hash)集合类(HashMap、HashSet 和 Hashtable)结合在一起正常运行。"
				}
			]
		},
		{
			"ID": "20220124162835-3rusyus",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-3rusyus",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7.set，map，list 的区别（尽量详细）"
				}
			]
		},
		{
			"ID": "20220124162835-d8cpabz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-d8cpabz",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "map:"
				}
			]
		},
		{
			"ID": "20220124162835-n7o58hk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-n7o58hk",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "hashmap:链地址法,大概思路：通过取 key 的 hashCode 值、高位运算、取模运算计算位置，插入位置是通过 hascode 和 eques 方法判断 key 是否一致"
				}
			]
		},
		{
			"ID": "20220124162835-j3i25vq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-j3i25vq",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "①.判断键值对数组 table[i]是否为空或为 null，否则执行 resize()进行扩容；"
				}
			]
		},
		{
			"ID": "20220124162835-ujbkf63",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-ujbkf63",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "②.根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加，转向⑥，如果 table[i]不为空，转向③；"
				}
			]
		},
		{
			"ID": "20220124162835-u547o5l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-u547o5l",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "③.判断 table[i]的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向④，这里的相同指的是 hashCode 以及 equals；"
				}
			]
		},
		{
			"ID": "20220124162835-aeso8ue",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-aeso8ue",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "④.判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；"
				}
			]
		},
		{
			"ID": "20220124162835-yd2wg1v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-yd2wg1v",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "⑤.遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；"
				}
			]
		},
		{
			"ID": "20220124162835-fwmul6s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-fwmul6s",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "⑥.插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。"
				}
			]
		},
		{
			"ID": "20220124162835-9gu7frk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-9gu7frk",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "treemap:TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。"
				}
			]
		},
		{
			"ID": "20220124162835-egrbwv5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-egrbwv5",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "linkedHashMap:保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。"
				}
			]
		},
		{
			"ID": "20220124162835-zswzruy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-zswzruy",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "HashTable:因为内部是采用 synchronized 来保证线程安全的"
				}
			]
		},
		{
			"ID": "20220124162835-55olqhx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-55olqhx",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "CocurrentHashMap:利用锁分段技术增加了锁的数目，从而使争夺同一把锁的线程的数目得到控制。"
				}
			]
		},
		{
			"ID": "20220124162835-84r3819",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-84r3819",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "set:"
				}
			]
		},
		{
			"ID": "20220124162835-n7typ3u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-n7typ3u",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "HashSet:内部 new 了一个 hashMap,添加时 key 放数据，value 放一个内部定义的 final 的 Object 对象"
				}
			]
		},
		{
			"ID": "20220124162835-jxxrjc1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-jxxrjc1",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "LinkedHashSet：内部 new 了一个 linkHashMap,添加时 key 放数据，value 放一个内部定义的 final 的 Object 对象,遍历时有序"
				}
			]
		},
		{
			"ID": "20220124162835-m2w7gcp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-m2w7gcp",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "TreeSet:内部 new 了一个 TreeMap,添加时 key 放数据，value 放一个内部定义的 final 的 Object 对象."
				}
			]
		},
		{
			"ID": "20220124162835-4jlo96w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-4jlo96w",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "list:"
				}
			]
		},
		{
			"ID": "20220124162835-5xm8fk0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-5xm8fk0",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "arraylist 和 linkedList(略)"
				}
			]
		},
		{
			"ID": "20220124162835-5uqwknv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-5uqwknv",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "copywriteList：CopyOnWriteArrayList 适合使用在读操作远远大于写操作的场景"
				}
			]
		},
		{
			"ID": "20220124162835-16s8lny",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-16s8lny",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一、java 基础"
				}
			]
		},
		{
			"ID": "20220124162835-6vuzlu4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-6vuzlu4",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.1 请你说明 String 和 StringBuffer 的区别"
				}
			]
		},
		{
			"ID": "20220124162835-wun7rii",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-wun7rii",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.2 请你说明一下 int 和 Integer 有什么区别"
				}
			]
		},
		{
			"ID": "20220124162835-g07fkiy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-g07fkiy",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.3 数组(Array)和列表(ArrayList)的区别？什么时候应该使用 Array 而不是 ArrayList？"
				}
			]
		},
		{
			"ID": "20220124162835-zpbtzzn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-zpbtzzn",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.4 什么是值传递和引用传递？"
				}
			]
		},
		{
			"ID": "20220124162835-v70mubd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-v70mubd",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.5Java 支持的数据类型有哪些？什么是自动拆装箱？"
				}
			]
		},
		{
			"ID": "20220124162835-4pi7rf0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-4pi7rf0",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.6 为什么会出现 4.0-3.6=0.40000001 这种现象？"
				}
			]
		},
		{
			"ID": "20220124162835-dgjjl5z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-dgjjl5z",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.7java8 的新特性吗，请简单介绍一下"
				}
			]
		},
		{
			"ID": "20220124162835-9lvnnap",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-9lvnnap",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.8 你说明符号“==”比较的是什么？"
				}
			]
		},
		{
			"ID": "20220124162835-so3ho4a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-so3ho4a",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.9Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"
				}
			]
		},
		{
			"ID": "20220124162835-gg6f4f7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-gg6f4f7",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.10 为什么重写 equals 还要重写 hashcode？"
				}
			]
		},
		{
			"ID": "20220124162835-4bon8vn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-4bon8vn",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.11 若对一个类不重写，它的 equals()方法是如何比较的？"
				}
			]
		},
		{
			"ID": "20220124162835-9u35gxy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-9u35gxy",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二、关键字"
				}
			]
		},
		{
			"ID": "20220124162835-8bhlnqf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-8bhlnqf",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.1Java 里面的 final 关键字是怎么用的？"
				}
			]
		},
		{
			"ID": "20220124162835-ycvq29w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-ycvq29w",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.2 谈谈关于 Synchronized 和 lock"
				}
			]
		},
		{
			"ID": "20220124162835-f66yga1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-f66yga1",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.3 请你介绍一下 volatile？"
				}
			]
		},
		{
			"ID": "20220124162835-fwi8sm9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-fwi8sm9",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.4 请你介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"
				}
			]
		},
		{
			"ID": "20220124162835-x19j9mx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-x19j9mx",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三.面向对象"
				}
			]
		},
		{
			"ID": "20220124162835-lxzjizf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-lxzjizf",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.1Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"
				}
			]
		},
		{
			"ID": "20220124162835-798tp4l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-798tp4l",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.2 如何通过反射获取和设置对象私有字段的值？"
				}
			]
		},
		{
			"ID": "20220124162835-u113ut9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-u113ut9",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.3 请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"
				}
			]
		},
		{
			"ID": "20220124162835-fyur3ct",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-fyur3ct",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.4 当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"
				}
			]
		},
		{
			"ID": "20220124162835-jj4l66q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-jj4l66q",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.5 什么是泛型？"
				}
			]
		},
		{
			"ID": "20220124162835-79gm7pd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-79gm7pd",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.6 解释一下类加载机制，双亲委派模型，好处是什么？"
				}
			]
		},
		{
			"ID": "20220124162835-dvi7wqd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-dvi7wqd",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.7”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？"
				}
			]
		},
		{
			"ID": "20220124162835-49w4ev9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-49w4ev9",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.8 列举你所知道的 Object 类的方法并简要说明。"
				}
			]
		},
		{
			"ID": "20220124162835-edzaxiw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220124162835-edzaxiw",
				"updated": "20220124162835"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.9 类和对象的区别"
				}
			]
		}
	]
}