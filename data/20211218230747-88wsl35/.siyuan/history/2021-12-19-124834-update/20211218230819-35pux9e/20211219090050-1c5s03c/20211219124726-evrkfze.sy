{
	"ID": "20211219124726-evrkfze",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20211219124726-evrkfze",
		"title": "\u0026lt;cache\u0026gt;\u0026lt;cache-ref\u0026gt;_缓存",
		"updated": "20211219090142"
	},
	"Children": [
		{
			"ID": "20211219090142-8vu9w2l",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20211219090142-8vu9w2l",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "缓存"
				}
			]
		},
		{
			"ID": "20211219090142-wml885k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-wml885k",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。"
				}
			]
		},
		{
			"ID": "20211219090142-0gmj00j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-0gmj00j",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行："
				}
			]
		},
		{
			"ID": "20211219090142-sxt8ocs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-sxt8ocs",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "\u003ccache/\u003e"
				}
			]
		},
		{
			"ID": "20211219090142-67wfv2z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-67wfv2z",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "基本上就是这样。这个简单语句的效果如下:"
				}
			]
		},
		{
			"ID": "20211219090142-v5p9ipl",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20211219090142-v5p9ipl",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"ID": "20211219090142-cht8g4x",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-cht8g4x"
					},
					"Children": [
						{
							"ID": "20211219090142-y92ljme",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-y92ljme"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "映射语句文件中的所有 select 语句的结果将会被缓存。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-2p082qh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-2p082qh"
					},
					"Children": [
						{
							"ID": "20211219090142-4ttgjv9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-4ttgjv9"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-d3oqypq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-d3oqypq"
					},
					"Children": [
						{
							"ID": "20211219090142-vj16omx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-vj16omx"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-kakqqsb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-kakqqsb"
					},
					"Children": [
						{
							"ID": "20211219090142-l8zmf4z",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-l8zmf4z"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "缓存不会定时进行刷新（也就是说，没有刷新间隔）。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-mlnk7ln",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-mlnk7ln"
					},
					"Children": [
						{
							"ID": "20211219090142-c21dkhm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-c21dkhm"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-q5mpt8p",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-q5mpt8p"
					},
					"Children": [
						{
							"ID": "20211219090142-ezo161v",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-ezo161v"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20211219090142-qqrfim6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-qqrfim6",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "提示 缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。"
				}
			]
		},
		{
			"ID": "20211219090142-i7glb2m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-i7glb2m",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这些属性可以通过 cache 元素的属性来修改。比如："
				}
			]
		},
		{
			"ID": "20211219121731-hud3x1f",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20211219121731-hud3x1f",
				"updated": "20211219121736"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eG1s"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003ccache\neviction=\"FIFO\"\nflushInterval=\"60000\"\nsize=\"512\"\nreadOnly=\"true\"/\u003e\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20211219090142-mq7adz6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-mq7adz6",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。"
				}
			]
		},
		{
			"ID": "20211219090142-7pg39uw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-7pg39uw",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可用的清除策略有："
				}
			]
		},
		{
			"ID": "20211219090142-cv364he",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20211219090142-cv364he",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"ID": "20211219090142-b5i3z1w",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-b5i3z1w"
					},
					"Children": [
						{
							"ID": "20211219090142-x003zll",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-x003zll"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "LRU – 最近最少使用：移除最长时间不被使用的对象。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-494qqor",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-494qqor"
					},
					"Children": [
						{
							"ID": "20211219090142-sifyiwg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-sifyiwg"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "FIFO – 先进先出：按对象进入缓存的顺序来移除它们。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-dfqv2rc",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-dfqv2rc"
					},
					"Children": [
						{
							"ID": "20211219090142-wenrsea",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-wenrsea"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。"
								}
							]
						}
					]
				},
				{
					"ID": "20211219090142-sb6je1h",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20211219090142-sb6je1h"
					},
					"Children": [
						{
							"ID": "20211219090142-rq5lzpv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20211219090142-rq5lzpv"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20211219090142-bnd9417",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-bnd9417",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "默认的清除策略是 LRU。"
				}
			]
		},
		{
			"ID": "20211219090142-azdwufh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-azdwufh",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。"
				}
			]
		},
		{
			"ID": "20211219090142-psh9qz7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-psh9qz7",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。"
				}
			]
		},
		{
			"ID": "20211219090142-50c1j01",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-50c1j01",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。"
				}
			]
		},
		{
			"ID": "20211219090142-65ave8m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-65ave8m",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "提示 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。"
				}
			]
		},
		{
			"ID": "20211219090142-8r57huv",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20211219090142-8r57huv",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用自定义缓存"
				}
			]
		},
		{
			"ID": "20211219090142-jo111r8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-jo111r8",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "除了上述自定义缓存的方式，你也可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。"
				}
			]
		},
		{
			"ID": "20211219090142-q8t9360",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20211219090142-q8t9360",
				"updated": "20211219122011"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eG1s"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003ccache type=\"com.domain.something.MyCustomCache\"/\u003e\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20211219090142-2kb3g28",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-2kb3g28",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个示例展示了如何使用一个自定义的缓存实现。type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器。 这个接口是 MyBatis 框架中许多复杂的接口之一，但是行为却非常简单。"
				}
			]
		},
		{
			"ID": "20211219121742-gxtbiq7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20211219121742-gxtbiq7",
				"updated": "20211219121805"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public interface Cache {\n\tString getId();\n\tint getSize();\n\tvoid putObject(Object key, Object value);\n\tObject getObject(Object key);\n\tboolean hasKey(Object key);\n\tObject removeObject(Object key);\n\tvoid clear();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20211219090142-bepq0cm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-bepq0cm",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了对你的缓存进行配置，只需要简单地在你的缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如，下面的例子将在你的缓存实现上调用一个名为 setCacheFile(String file) 的方法："
				}
			]
		},
		{
			"ID": "20211219121810-8tt4r9b",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20211219121810-8tt4r9b",
				"updated": "20211219121835"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eG1s"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003ccache type=\"com.domain.something.MyCustomCache\"\u003e\n\t\u003cproperty name=\"cacheFile\" value=\"/tmp/my-custom-cache.tmp\"/\u003e\n\u003c/cache\u003e\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20211219090142-bxcit48",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-bxcit48",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "你可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。 你也可以使用占位符（如 ${cache.file}），以便替换成在"
				},
				{
					"Type": "NodeLink",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "配置文件属性"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://mybatis.org/mybatis-3/zh/configuration.html#properties"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "中定义的值。"
				}
			]
		},
		{
			"ID": "20211219121850-q2vkjrm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20211219121850-q2vkjrm",
				"updated": "20211219121915"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 从版本 3.4.2 开始，MyBatis 已经支持在所有属性设置完毕之后，调用一个初始化方法。 如果想要使用这个特性，请在你的自定义缓存类里实现 org.apache.ibatis.builder.InitializingObject 接口。\npublic interface InitializingObject {\n\tvoid initialize() throws Exception;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20211219090142-ijw59ji",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-ijw59ji",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "提示 上一节中对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存。"
				}
			]
		},
		{
			"ID": "20211219090142-eu3njpg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-eu3njpg",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "请注意，缓存的配置和缓存实例会被绑定到 SQL 映射文件的命名空间中。 因此，同一命名空间中的所有语句和缓存将通过命名空间绑定在一起。 每条语句可以自定义与缓存交互的方式，或将它们完全排除于缓存之外，这可以通过在每条语句上使用两个简单属性来达成。 默认情况下，语句会这样来配置："
				}
			]
		},
		{
			"ID": "20211219090142-n1l0nr3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20211219090142-n1l0nr3",
				"updated": "20211219122019"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eG1s"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003cselect ... flushCache=\"false\" useCache=\"true\"/\u003e\n\u003cinsert ... flushCache=\"true\"/\u003e\n\u003cupdate ... flushCache=\"true\"/\u003e\n\u003cdelete ... flushCache=\"true\"/\u003e\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20211219090142-sv47n1v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-sv47n1v",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "鉴于这是默认行为，显然你永远不应该以这样的方式显式配置一条语句。但如果你想改变默认的行为，只需要设置 flushCache 和 useCache 属性。比如，某些情况下你可能希望特定 select 语句的结果排除于缓存之外，或希望一条 select 语句清空缓存。类似地，你可能希望某些 update 语句执行时不要刷新缓存。"
				}
			]
		},
		{
			"ID": "20211219090142-6mv2tph",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20211219090142-6mv2tph",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "cache-ref"
				}
			]
		},
		{
			"ID": "20211219090142-4eos4nv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20211219090142-4eos4nv",
				"updated": "20211219090142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "回想一下上一节的内容，对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。"
				}
			]
		},
		{
			"ID": "20211219121959-lwp7u2l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20211219121959-lwp7u2l",
				"updated": "20211219122002"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eG1s"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003ccache-ref namespace=\"com.someone.application.data.SomeMapper\"/\u003e\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}